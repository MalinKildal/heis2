//Calculates cost, returns 1 if myElev got the lowest cost
func getCost(orderFloor int, orderDirection int) int {

	myCost := 1 //regner ut egen cost
	elevOneCost := 1 //reger ut elev1 sin cost ut fra ElevatorPositions.ElevOneFloor og ElevatorPositions.ElevOneDirection
	elevTwoCost := 1 //reger ut elev2 sin cost ut fra ElevatorPositions.ElevTwoFloor og ElevatorPositions.ElevTwoDirection

	if (myCost < elevOneCost) && (myCost < elevTwoCost) {
		return 1
	} else if (myCost == elevOneCost) {
		if myAdress < ElevOneAdress {		//myAdress må lages!!!
			return 1
		}
		return 0
	} else if (myCost == elevOneCost) {
		if myAdress < ElevOneAdress {
			return 1
		}
		return 0
	}
	return 0
}




//Receives orders from other elevators
func ReceiveOrder() {
	for {
		var receivedMessage Udp_message
		receivedMessage = <- receive_ch
		
		var receivedOrder Order
		
		err := json.Unmarshal(receivedMessage.Data, &receivedOrder)
		
		if (err != nil) {
			println("Receive Order Error: ", err)
		}
		
		//Init messages from the other elevators
		if (ElevOneAdress == nil) {
			ElevOneAdress = receivedMessage.Raddr
		} else if (ElevTwoAdress == nil) {
			ElevTwoAdress = receivedMessage.Raddr
		}
		
		//Set other elevators positon
		if (receivedMessage.Raddr == ElevOneAdress) {
			ElevOneFloor = receivedOrder.MyFloor
			ElevOneDirection = receivedOrder.MyDirection
		
		} else if (receivedMessage.Raddr == ElevTwoAdress) {
			ElevTwoFloor = receivedOrder.MyFloor
			ElevTwoDirection = receivedOrder.MyDirection
		}
		
		cost := getCost(receivedOrder.Floor, receivedOrder.Direction)
		
		if cost == 1 {
			UpdateMyOrders(receivedOrder)
		}
		UpdateGlobalOrders(receivedOrder)
	}
	
}





//Settes i deleteOrder og sender en int med hvilken etg som må resettes.
var orderHandled chan int

//Settes i UpdateGlobalOrder (ikke dersom orderen eksisterte fra før) og resetter timeren til 10 sek
var setOrder chan int


func checkGlobalOrders() {
	
	OneUpTimer := NewTimer(Hour*3)
	TwoUpTimer := NewTimer(Hour*3)
	ThreeUpTimer := NewTimer(Hour*3)
	TwoDownTimer := NewTimer(Hour*3)
	ThreeDownTimer := NewTimer(Hour*3)
	FourDownTimer := NewTimer(Hour*3)
	
	for {
		select {
		
		case orderHandledAtFloor := <- orderHandled:
			
			If orderHandledAtFloor == 0 {
				OneUpTimer.Reset(3*Hour)
			} else if orderHandledAtFloor == 1 {
				TwoUpTimer.Reset(3*Hour)
			} else if orderHandledAtFloor == 2 {
				ThreeUpTimer.Reset(3*Hour)
			} else if orderHandledAtFloor == 3 {
				TwoDownTimer.Reset(3*Hour)
			} else if orderHandledAtFloor == 4 {
				ThreeDownTimer.Reset(3*Hour)
			} else if orderHandledAtFloor == 5 {
				FourDownTimer.Reset(3*Hour)
			}
		
		case setOrderAtFloor := <- setOrder:
			
			If setOrderAtFloor == 0 {
				OneUpTimer.Reset(10*Second)
			} else if setOrderAtFloor == 1 {
				TwoUpTimer.Reset(10*Second)
			} else if setOrderAtFloor == 2 {
				ThreeUpTimer.Reset(10*Second)
			} else if setOrderAtFloor == 3 {
				TwoDownTimer.Reset(10*Second)
			} else if setOrderAtFloor == 4 {
				ThreeDownTimer.Reset(10*Second)
			} else if setOrderAtFloor == 5 {
				FourDownTimer.Reset(10*Second)
			}
			
		case <- OneUpTimer.C:
			println("Order up in first floor has not been handled")
			newOrder := Order{myFloor, myDirection, 0, 1, false}
		case <- TwoUpTimer.C:
			println("Order up in second floor has not been handled")
			newOrder := Order{myFloor, myDirection, 1, 1, false}
		case <- ThreeUpTimer.C:
			println("Order up in third floor has not been handled")
			newOrder := Order{myFloor, myDirection, 2, 1, false}
		case <- TwoDownTimer.C:
			println("Order down in second floor has not been handled")
			newOrder := Order{myFloor, myDirection, 1, 0, false}
		case <- ThreeDownTimer.C:
			println("Order down in third floor has not been handled")
			newOrder := Order{myFloor, myDirection, 2, 0, false}
		case <- FourDownTimer.C:
			println("Order down in fourth floor has not been handled")
			newOrder := Order{myFloor, myDirection, 3, 0, false}
	
	}	
}




Looper gjennom GlobalOrders
Setter timer på hver order som blir true
Om en time går ut hopper den inn i rett case, og behandler orderen









func UpdateGlobalOrders(receivedOrder Order) {

	if receivedOrder.OrderHandledAtFloor {
		
		globalOrders[receivedOrder.Floor] = false
		globalOrders[N_FLOORS-2 + receivedOrder.Floor] = false
		orderHandled <- receivedOrder.Floor
		
		if (receivedOrder.Floor < N_FLOORS-1) {
			Elev_set_button_lamp(BUTTON_CALL_UP, receivedOrder.Floor, 0)
		}
		if (receivedOrder.Floor > 0) {
			Elev_set_button_lamp(BUTTON_CALL_DOWN, receivedOrder.Floor, 0)
		}
		
	} else {
	
		if receivedOrder.Direction == 1 {
			globalOrders[receivedOrder.Floor] = true
			Elev_set_button_lamp(BUTTON_CALL_UP, receivedOrder.Floor, 1)
			setOrder <- receivedOrder.Floor
		} else if receivedOrder.Direction == 0 {
			globalOrders[N_FLOORS-2 + receivedOrder.Floor] = true
			Elev_set_button_lamp(BUTTON_CALL_DOWN, receivedOrder.Floor, 1)
			setOrder <- N_FLOORS-2 + receivedOrder.Floor
		} else {
			println("Not valid direction, or unvalid floor")
		}
		
	}
}






func DeleteAllOrders() {
	for j:=0; j<N_FLOORS*2-2; j++ {
		globalOrders[j] = false
		orderHandled <- i
	}

	for j:=0; j<N_FLOORS; j++ {
		inside[j] = false
	}

	for j:=0; j<N_FLOORS; j++ {
		up[j] = false
	}

	for j:=0; j<N_FLOORS; j++ {
		down[j] = false
	}
}




